// When the `system-alloc` feature is used, use the System Allocator
#[cfg(feature = "system-alloc")]
use std::alloc::System;
use std::collections::{HashSet, LinkedList};
use std::ops::Deref;
#[cfg(feature = "system-alloc")]
#[global_allocator]
static GLOBAL: System = System;

extern crate xresloader_protocol;

extern crate clap;

#[macro_use]
extern crate log;
extern crate bytes;
extern crate env_logger;
extern crate json;
extern crate protobuf_json_mapping;
extern crate regex;

use clap::{ArgAction, Parser};
use std::collections::HashMap;
use std::fs::File;
use std::io::{BufRead, BufReader, Read, Write};

use protobuf::{descriptor::FileDescriptorSet, Message, MessageDyn, MessageFull};
// use xresloader_protocol::proto::Xresloader_datablocks;

mod file_descriptor_index;
mod ordered_generator;

use file_descriptor_index::FileDescriptorIndex;

/// Simple program to greet a person
#[derive(Parser, Debug)]
#[command(version, about, long_about = None)]
struct DumpOptions {
    /// pb files(can be used mulpitle times)
    #[arg(short, long, value_parser, action = ArgAction::Append)]
    pb_file: Vec<String>,

    /// binary files generated by xresloader(can be used mulpitle times)
    #[arg(short, long, value_parser, action = ArgAction::Append)]
    bin_file: Vec<String>,

    /// Debug mode
    #[arg(long, value_parser, default_value = "false")]
    debug: bool,

    /// Pretty mode
    #[arg(long, value_parser, default_value = "false")]
    pretty: bool,

    /// Plain mode
    #[arg(long, value_parser, default_value = "false")]
    plain: bool,

    /// head_only mode
    #[arg(long, value_parser, default_value = "false")]
    head_only: bool,

    /// silence mode
    #[arg(long, value_parser, default_value = "false")]
    silence: bool,

    /// Output string table as json
    #[arg(
        long,
        value_parser,
        default_value = "",
        value_name = "OUTPUT JSON FILE PATH"
    )]
    output_string_table_json: String,

    /// Output string table as text lines
    #[arg(
        long,
        value_parser,
        default_value = "",
        value_name = "OUTPUT TEXT FILE PATH"
    )]
    output_string_table_text: String,

    /// Field value include matching rule for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "REGEX")]
    string_table_include_value_regex_rule: Vec<String>,

    /// Load field value include matching rule(regex) from file for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "REGEX")]
    string_table_include_value_regex_file: Vec<String>,

    /// Field value exclude matching rule for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "REGEX FILE PATH")]
    string_table_exclude_value_regex_rule: Vec<String>,

    /// Load field value exclude matching rule(regex) from file for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "REGEX FILE PATH")]
    string_table_exclude_value_regex_file: Vec<String>,

    /// Load field include path from file for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "FILE PATH")]
    string_table_include_field_path_file: Vec<String>,

    /// Load field exclude path from file for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "FILE PATH")]
    string_table_exclude_field_path_file: Vec<String>,

    /// Load message exclude path from file for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "FILE PATH")]
    string_table_exclude_message_path_file: Vec<String>,

    /// Load message include path from file for string table(can be used mulpitle times)
    #[arg(long, value_parser, action = ArgAction::Append, value_name = "FILE PATH")]
    string_table_include_message_path_file: Vec<String>,

    /// String table pretty mode
    #[arg(long, value_parser, default_value = "false")]
    string_table_pretty: bool,
}

struct Logger {
    stdout: Box<env_logger::Logger>,
    stderr: Box<env_logger::Logger>,
}

#[derive(Clone)]
struct StringTableDataSource {
    pub file: ::std::string::String,
    pub sheet: ::std::string::String,
    pub count: i32,
}

struct StringTableBinarySource {
    pub xres_ver: ::std::string::String,
    pub data_ver: ::std::string::String,
    pub bin_file: ::std::string::String,
    pub count: u32,
    pub hash_code: ::std::string::String,
    pub description: ::std::string::String,
    pub data_source: ::std::vec::Vec<StringTableDataSource>,
}

struct StringTableItemSource {
    pub file: ::std::string::String,
    pub sheet: ::std::string::String,
}

struct StringTableContent {
    pub head: StringTableBinarySource,
    pub body: HashMap<String, LinkedList<StringTableItemSource>>,
}

#[derive(Default)]
struct StringTableFilter {
    pub value_include_regex_rules: Vec<regex::Regex>,
    pub value_exclude_regex_rules: Vec<regex::Regex>,
    pub include_message_paths: HashSet<String>,
    pub exclude_message_paths: HashSet<String>,
    pub include_field_paths: HashSet<String>,
    pub exclude_field_paths: HashSet<String>,
}

impl StringTableFilter {
    pub fn filter_value(&self, input: &str) -> bool {
        if !self.value_include_regex_rules.is_empty() {
            let mut matched = false;
            for rule in &self.value_include_regex_rules {
                if rule.is_match(input) {
                    matched = true;
                    break;
                }
            }
            if !matched {
                return false;
            }
        }
        for rule in &self.value_exclude_regex_rules {
            if rule.is_match(input) {
                return false;
            }
        }

        true
    }

    pub fn filter_field_full_name(&self, input: &str) -> bool {
        if !self.include_field_paths.is_empty() && !self.include_field_paths.contains(input) {
            return false;
        }

        if self.exclude_field_paths.contains(input) {
            return false;
        }

        true
    }

    pub fn filter_message_full_name(&self, input: &str) -> bool {
        if !self.include_message_paths.is_empty() && !self.include_message_paths.contains(input) {
            return false;
        }

        if self.exclude_message_paths.contains(input) {
            return false;
        }

        true
    }
}

impl StringTableContent {
    pub fn load_message(
        &mut self,
        message: &dyn MessageDyn,
        filter: &StringTableFilter,
        data_source: &StringTableDataSource,
    ) {
        if !filter.filter_message_full_name(message.descriptor_dyn().full_name()) {
            return;
        }

        message
            .descriptor_dyn()
            .fields()
            .for_each(|field| match field.runtime_field_type() {
                protobuf::reflect::RuntimeFieldType::Singular(_) => {
                    if let Some(v) = field.get_singular(message) {
                        match v {
                            protobuf::reflect::ReflectValueRef::Message(m) => {
                                self.load_message(m.deref(), filter, data_source);
                            }
                            protobuf::reflect::ReflectValueRef::String(s) => {
                                if !filter.filter_field_full_name(&field.full_name()) {
                                    return;
                                }

                                if !filter.filter_value(s) {
                                    return;
                                }

                                let value = v.to_string();
                                if let Some(item) = self.body.get_mut(&value) {
                                    item.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                } else {
                                    let mut ls = LinkedList::new();
                                    ls.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                    self.body.insert(value, ls);
                                }
                            }
                            _ => {}
                        }
                    }
                }
                protobuf::reflect::RuntimeFieldType::Repeated(_) => {
                    if !filter.filter_field_full_name(&field.full_name()) {
                        return;
                    }

                    field
                        .get_repeated(message)
                        .into_iter()
                        .for_each(|v| match v {
                            protobuf::reflect::ReflectValueRef::Message(m) => {
                                self.load_message(m.deref(), filter, data_source);
                            }
                            protobuf::reflect::ReflectValueRef::String(s) => {
                                if !filter.filter_value(s) {
                                    return;
                                }

                                let value = v.to_string();
                                if let Some(item) = self.body.get_mut(&value) {
                                    item.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                } else {
                                    let mut ls = LinkedList::new();
                                    ls.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                    self.body.insert(value, ls);
                                }
                            }
                            _ => {}
                        })
                }
                protobuf::reflect::RuntimeFieldType::Map(_, _) => {
                    field.get_map(message).into_iter().for_each(|(k, v)| {
                        match k {
                            protobuf::reflect::ReflectValueRef::Message(m) => {
                                self.load_message(m.deref(), filter, data_source);
                            }
                            protobuf::reflect::ReflectValueRef::String(s) => {
                                if !filter.filter_field_full_name(&field.full_name()) {
                                    return;
                                }

                                if !filter.filter_value(s) {
                                    return;
                                }

                                let value = v.to_string();
                                if let Some(item) = self.body.get_mut(&value) {
                                    item.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                } else {
                                    let mut ls = LinkedList::new();
                                    ls.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                    self.body.insert(value, ls);
                                }
                            }
                            _ => {}
                        }

                        match v {
                            protobuf::reflect::ReflectValueRef::Message(m) => {
                                self.load_message(m.deref(), filter, data_source);
                            }
                            protobuf::reflect::ReflectValueRef::String(s) => {
                                if !filter.filter_field_full_name(&field.full_name()) {
                                    return;
                                }

                                if !filter.filter_value(s) {
                                    return;
                                }

                                let value = v.to_string();
                                if let Some(item) = self.body.get_mut(&value) {
                                    item.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                } else {
                                    let mut ls = LinkedList::new();
                                    ls.push_back(StringTableItemSource {
                                        file: data_source.file.clone(),
                                        sheet: data_source.sheet.clone(),
                                    });
                                    self.body.insert(value, ls);
                                }
                            }
                            _ => {}
                        }
                    });
                }
            });
    }

    pub fn to_json(&self) -> json::JsonValue {
        let mut json_item = json::JsonValue::new_object();
        let mut json_item_head = json::JsonValue::new_object();
        let mut json_item_body = json::JsonValue::new_object();

        let _ = json_item_head.insert("xres_ver", self.head.xres_ver.clone());
        let _ = json_item_head.insert("data_ver", self.head.data_ver.clone());
        let _ = json_item_head.insert("bin_file", self.head.bin_file.clone());
        let _ = json_item_head.insert("count", self.head.count);
        let _ = json_item_head.insert("hash_code", self.head.hash_code.clone());
        let _ = json_item_head.insert("description", self.head.description.clone());
        let _ = json_item_head.insert("data_source", {
            let mut ds = json::JsonValue::new_array();
            for source in &self.head.data_source {
                let mut d = json::JsonValue::new_object();
                let _ = d.insert("file", source.file.clone());
                let _ = d.insert("sheet", source.sheet.clone());
                if source.count > 0 {
                    let _ = d.insert("count", source.count);
                }
                let _ = ds.push(d);
            }

            ds
        });

        for row in &self.body {
            let mut body_item = json::JsonValue::new_object();
            let mut body_item_source = json::JsonValue::new_array();
            for source in row.1 {
                let mut d = json::JsonValue::new_object();
                let _ = d.insert("file", source.file.clone());
                let _ = d.insert("sheet", source.sheet.clone());
                let _ = body_item_source.push(d);
            }
            let _ = body_item.insert("source", body_item_source);
            let _ = json_item_body.insert(row.0, body_item);
        }

        let _ = json_item.insert("head", json_item_head);
        let _ = json_item.insert("body", json_item_body);
        json_item
    }

    pub fn to_text(&self) -> HashSet<String> {
        let mut ret = HashSet::new();
        for row in &self.body {
            let _ = ret.insert(row.0.clone());
        }

        ret
    }
}

impl Logger {
    pub fn new(max_log_level: log::LevelFilter) -> Self {
        Self {
            stdout: Box::new(
                env_logger::Builder::new()
                    .filter_level(max_log_level)
                    .format_level(false)
                    .format_module_path(false)
                    .format_target(false)
                    .format_timestamp(None)
                    .target(env_logger::Target::Stdout)
                    .parse_default_env()
                    .build(),
            ),
            stderr: Box::new(
                env_logger::Builder::new()
                    .filter_level(log::LevelFilter::Warn)
                    .format_level(false)
                    .format_module_path(false)
                    .format_target(false)
                    .format_timestamp(None)
                    .target(env_logger::Target::Stderr)
                    .parse_default_env()
                    .build(),
            ),
        }
    }

    pub fn init(self) -> Result<(), log::SetLoggerError> {
        let max_level = self.stdout.filter();
        let r = log::set_boxed_logger(Box::new(self));

        if r.is_ok() {
            log::set_max_level(max_level);
        }

        r
    }
}

impl log::Log for Logger {
    fn enabled(&self, metadata: &log::Metadata) -> bool {
        self.stdout.enabled(metadata) || self.stderr.enabled(metadata)
    }

    fn log(&self, record: &log::Record) {
        if self.stderr.enabled(record.metadata()) {
            self.stderr.log(record);
        } else if self.stdout.enabled(record.metadata()) {
            self.stdout.log(record);
        }
    }

    fn flush(&self) {
        self.stdout.flush();
        self.stderr.flush();
    }
}

fn load_file_by_lines<P>(file_path: &str, file_type: &str, has_error: &mut bool, func: P)
where
    P: FnMut(&str) -> Result<(), String>,
{
    let mut invoke = func;
    match std::fs::OpenOptions::new()
        .read(true)
        .write(false)
        .open(file_path)
    {
        Ok(f) => {
            let reader = BufReader::new(f);
            reader
                .lines()
                .map_while(Result::ok)
                .map(|s| s.trim().to_string())
                .filter(|s| !s.is_empty() && !s.starts_with('#'))
                .for_each(|line| {
                    if let Err(e) = invoke(&line) {
                        error!(
                            "Invalid {}: \"{}\" in file {}, {}, ignore this line",
                            file_type, line, file_path, e
                        );
                        *has_error = true;
                    }
                })
        }
        Err(e) => {
            error!(
                "Try to open {} file {} failed, {}, ignore this file",
                file_type, file_path, e
            );
            *has_error = true;
        }
    }
}

fn build_string_table_filter(args: &DumpOptions) -> (bool, StringTableFilter) {
    let mut ret: StringTableFilter = StringTableFilter::default();
    let mut has_error = false;

    for regex_rule in &args.string_table_include_value_regex_rule {
        match regex::Regex::new(regex_rule) {
            Ok(r) => {
                ret.value_include_regex_rules.push(r);
            }
            Err(e) => {
                error!(
                    "Invalid regex rule: {}, {}, ignore this rule",
                    regex_rule, e
                );
                has_error = true;
            }
        }
    }

    for file_path in &args.string_table_include_value_regex_file {
        load_file_by_lines(
            file_path,
            "regex rule",
            &mut has_error,
            |line| match regex::Regex::new(line) {
                Ok(r) => {
                    ret.value_include_regex_rules.push(r);
                    Ok(())
                }
                Err(e) => Err(format!("{}", e)),
            },
        );
    }

    for regex_rule in &args.string_table_exclude_value_regex_rule {
        match regex::Regex::new(regex_rule) {
            Ok(r) => {
                ret.value_exclude_regex_rules.push(r);
            }
            Err(e) => {
                error!(
                    "Invalid regex rule: {}, {}, ignore this rule",
                    regex_rule, e
                );
                has_error = true;
            }
        }
    }

    for file_path in &args.string_table_exclude_value_regex_file {
        load_file_by_lines(
            file_path,
            "regex rule",
            &mut has_error,
            |line| match regex::Regex::new(line) {
                Ok(r) => {
                    ret.value_exclude_regex_rules.push(r);
                    Ok(())
                }
                Err(e) => Err(format!("{}", e)),
            },
        );
    }

    for field_path_file in &args.string_table_include_field_path_file {
        load_file_by_lines(field_path_file, "field path", &mut has_error, |line| {
            ret.include_field_paths.insert(line.to_string());
            Ok(())
        });
    }

    for field_path_file in &args.string_table_exclude_field_path_file {
        load_file_by_lines(field_path_file, "field path", &mut has_error, |line| {
            ret.exclude_field_paths.insert(line.to_string());
            Ok(())
        });
    }

    for field_path_file in &args.string_table_include_message_path_file {
        load_file_by_lines(field_path_file, "message path", &mut has_error, |line| {
            ret.include_message_paths.insert(line.to_string());
            Ok(())
        });
    }

    for field_path_file in &args.string_table_exclude_message_path_file {
        load_file_by_lines(field_path_file, "message path", &mut has_error, |line| {
            ret.exclude_message_paths.insert(line.to_string());
            Ok(())
        });
    }

    (has_error, ret)
}

fn main() {
    let args = DumpOptions::parse();

    if args.debug {
        let _ = Logger::new(log::LevelFilter::Debug).init();
    } else {
        let _ = Logger::new(log::LevelFilter::Info).init();
    }

    let mut desc_index = FileDescriptorIndex::new();

    let mut string_tables: Vec<StringTableContent> = vec![];
    let (has_string_table_error, string_table_filter) = build_string_table_filter(&args);
    for pb_file in args.pb_file {
        debug!("Load pb file: {}", pb_file);
        match std::fs::OpenOptions::new()
            .read(true)
            .write(false)
            .open(&pb_file)
        {
            Ok(mut f) => {
                let mut bin_data = Vec::new();
                let _ = f.read_to_end(&mut bin_data);
                match FileDescriptorSet::parse_from_bytes(&bin_data) {
                    Ok(pbs) => {
                        debug!("Parse pb file: {} success", pb_file);
                        for pb_file_unit in &pbs.file {
                            debug!(
                                "  Found proto file: {} has {} message(s) and {} enum(s)",
                                pb_file_unit.name(),
                                pb_file_unit.message_type.len(),
                                pb_file_unit.enum_type.len()
                            );
                            desc_index.add_file(pb_file_unit, &pb_file);
                        }
                    }
                    Err(e) => {
                        error!("Parse pb file {} failed, {}, ignore this file", pb_file, e);
                    }
                }
            }
            Err(e) => {
                error!(
                    "Try to open file {} failed, {}, ignore this file",
                    pb_file, e
                );
            }
        }
    }

    let mut has_error = has_string_table_error;

    for bin_file in args.bin_file {
        debug!("Load xresloader output binary file: {}", bin_file);
        match std::fs::OpenOptions::new()
            .read(true)
            .write(false)
            .open(&bin_file)
        {
            Ok(mut f) => {
                let mut bin_data = Vec::new();
                let _ = f.read_to_end(&mut bin_data);
                match xresloader_protocol::proto::pb_header_v3::Xresloader_datablocks::parse_from_bytes(&bin_data) {
                    Ok(data_blocks) => {
                        if data_blocks.data_message_type.is_empty() {
                            has_error = true;
                            error!("File {} has no data_message_type, please use xresloader 2.6 or upper", &bin_file);
                            continue;
                        }
                        debug!("Parse {} from file: {} success, message type: {}",
                            xresloader_protocol::proto::pb_header_v3::Xresloader_datablocks::descriptor().full_name(), &bin_file,
                            &data_blocks.data_message_type
                        );

                        let message_descriptor = match desc_index.build_message_descriptor(&data_blocks.data_message_type) {
                            Ok(x) => x,
                            Err(_) => {
                                error!("Build message descriptor {} failed", &data_blocks.data_message_type);
                                has_error = true;
                                continue;
                            }
                        };

                        if !args.silence {
                            info!("======================== Header: {} ========================", &bin_file);
                            info!("xresloader version: {}", data_blocks.header.xres_ver);
                            info!("data version: {}", data_blocks.header.data_ver);
                            info!("data count: {}", data_blocks.header.count);
                            info!("hash code: {}", data_blocks.header.hash_code);
                            info!("description: {}", data_blocks.header.description);
                            if !data_blocks.header.data_source.is_empty() {
                                info!("data source:");
                            }
                            for data_source in &data_blocks.header.data_source {
                                if data_source.count > 0 {
                                    info!("  - file: {}, sheet: {}, count: {}", data_source.file, data_source.sheet, data_source.count);
                                } else {
                                    info!("  - file: {}, sheet: {}", data_source.file, data_source.sheet);
                                }
                            }
                        }

                        let mut current_string_table_head : Option<StringTableBinarySource> = None;

                        if !args.output_string_table_json.is_empty() || !args.output_string_table_text.is_empty() {
                            current_string_table_head = Some(StringTableBinarySource {
                                xres_ver: data_blocks.header.xres_ver.clone(),
                                data_ver: data_blocks.header.data_ver.clone(),
                                bin_file: bin_file.clone(),
                                count: data_blocks.header.count,
                                hash_code: data_blocks.header.hash_code.clone(),
                                description: data_blocks.header.description.clone(),
                                data_source: {
                                    let mut data_source = Vec::new();
                                    for source in &data_blocks.header.data_source {
                                        data_source.push(StringTableDataSource {
                                            file: source.file.clone(),
                                            sheet: source.sheet.clone(),
                                            count: source.count,
                                        });
                                    }
                                    data_source
                                },
                            });
                        }
                        if !args.silence {
                            info!("============ Body: {} -> {} ============", &bin_file, &data_blocks.data_message_type);
                        }
                        let mut row_index = 0;
                        if !args.plain && !args.head_only && !args.silence {
                            info!("[");
                        }
                        let mut current_string_table :Option<StringTableContent> = None;
                        if let Some(head) = current_string_table_head {
                            current_string_table = Some(StringTableContent {
                                head,
                                body: HashMap::new(),
                            });
                        }

                        let mut fallback_data_source =
                            StringTableDataSource {
                                file: String::from("[UNKNOWN]"),
                                sheet: String::from("[UNKNOWN]"),
                                count: 0,
                        };
                        let mut current_data_source_idx = 0;
                        let mut current_data_source_left_row = 0;
                        for row_data_block in &data_blocks.data_block {
                            row_index += 1;
                            if current_data_source_left_row <= 0 && current_data_source_idx < data_blocks.header.data_source.len() {
                                current_data_source_left_row = data_blocks.header.data_source[current_data_source_idx].count;
                                fallback_data_source = StringTableDataSource {
                                    file: data_blocks.header.data_source[current_data_source_idx].file.clone(),
                                    sheet: data_blocks.header.data_source[current_data_source_idx].sheet.clone(),
                                    count: data_blocks.header.data_source[current_data_source_idx].count,
                                };
                                current_data_source_idx += 1;
                            }
                            if current_data_source_left_row > 0 {
                                current_data_source_left_row -= 1;
                            }

                            match message_descriptor.parse_from_bytes(row_data_block) {
                                Ok(message) => {
                                    if let Some(ref mut string_table) = current_string_table {
                                        string_table.load_message(message.as_ref(), &string_table_filter, &fallback_data_source);
                                    }

                                    if args.head_only || args.silence {
                                        continue;
                                    }

                                    if args.pretty {
                                        if args.plain {
                                            info!("  ------------ Row {} ------------\n{}", row_index, protobuf::text_format::print_to_string_pretty(message.as_ref()));
                                            continue;
                                        }
                                        if let Ok(output) = protobuf_json_mapping::print_to_string(message.as_ref()) {
                                            info!("    {},",  ordered_generator::stringify_pretty(json::parse(&output).unwrap(), 2));
                                        } else {
                                            info!("{}", protobuf::text_format::print_to_string_pretty(message.as_ref()));
                                        }
                                    } else {
                                        if args.plain {
                                            info!("{}", protobuf::text_format::print_to_string(message.as_ref()));
                                            continue;
                                        }
                                        if let Ok(output) = protobuf_json_mapping::print_to_string(message.as_ref()) {
                                            info!("    {},",  ordered_generator::stringify(json::parse(&output).unwrap()));
                                        } else {
                                            info!("{}", protobuf::text_format::print_to_string_pretty(message.as_ref()));
                                        }
                                    }
                                }
                                Err(e) => {
                                    error!("Parse row {} to message {} failed, {}", row_index, &data_blocks.data_message_type, e);
                                    has_error = true;
                                    continue;
                                }
                            }
                        }
                        if !args.plain && !args.head_only && !args.silence {
                            info!("]");
                        }

                        if let Some(string_table) = current_string_table {
                            if !string_table.body.is_empty() {
                                string_tables.push(string_table);
                            }
                        }
                    }
                    Err(e) => {
                        error!("Parse {} from file {} failed, {}, ignore this file", xresloader_protocol::proto::pb_header_v3::Xresloader_datablocks::descriptor().full_name(), bin_file, e);
                        has_error = true;
                    }
                }
            }
            Err(e) => {
                error!(
                    "Try to open file {} failed, {}, ignore this file",
                    &bin_file, e
                );
                has_error = true;
            }
        }

        // 2.6.0
    }

    // Dump string table json
    if !args.output_string_table_json.is_empty() {
        match File::create(&args.output_string_table_json) {
            Ok(mut f) => {
                let mut json = json::JsonValue::new_array();
                for string_table in &string_tables {
                    let _ = json.push(string_table.to_json());
                }

                if args.pretty || args.string_table_pretty {
                    if let Err(e) = f.write_all(json::stringify_pretty(json, 2).as_bytes()) {
                        error!(
                            "Try to write string table to {} failed, {}",
                            args.output_string_table_json, e
                        );
                        has_error = true;
                    }
                } else if let Err(e) = f.write_all(json::stringify(json).as_bytes()) {
                    error!(
                        "Try to write string table to {} failed, {}",
                        args.output_string_table_json, e
                    );
                    has_error = true;
                }
            }
            Err(e) => {
                error!(
                    "Try to open {} to write string table failed, {}",
                    args.output_string_table_json, e
                );
                has_error = true;
            }
        }
    }

    // Dump string table text
    if !args.output_string_table_text.is_empty() {
        match File::create(&args.output_string_table_text) {
            Ok(mut f) => {
                let mut text: HashSet<String> = HashSet::new();
                for string_table in &string_tables {
                    text.extend(string_table.to_text());
                }

                for line in text {
                    let _ = f.write(line.as_bytes());
                    let _ = f.write(b"\n");
                }
            }
            Err(e) => {
                error!(
                    "Try to open {} to write string table failed, {}",
                    args.output_string_table_text, e
                );
                has_error = true;
            }
        }
    }

    if has_error {
        std::process::exit(1);
    }
}
